using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using Microsoft.SqlServer.Management.Smo;
using Nephrite.Web;

namespace Nephrite.Metamodel.DbSync
{
    internal class Table
    {
        internal string Name { get; set; }
        internal string PkName { get; set; }
		internal DataType PkType { get; set; }
		internal bool Identity { get; set; }
        internal List<Column> Columns { get; private set; }
        internal List<ForeignKey> ForeignKeys { get; private set; }
        internal List<Trigger> Triggers { get; private set; }

        internal Model Model;
		internal string Description { get; set; }

        public Table()
        {
            Columns = new List<Column>();
            ForeignKeys = new List<ForeignKey>();
            Triggers = new List<Trigger>();
            Identity = true;
			PkType = DataType.Int;
        }

        Microsoft.SqlServer.Management.Smo.Table t;
		    
        /// <summary>
        /// Синхронизация всего кроме внешних ключей
        /// </summary>
        internal void Sync()
        {
            Model.Log("Синхронизация " + Name);
			string[] pknames = PkName.Split(new char[] { ',' }, StringSplitOptions.RemoveEmptyEntries);

            if (Model.Database.Tables.Contains(Name))
            {
                t = Model.Database.Tables[Name];
                
                // Удалить лишние внешние ключи
                for (int i = t.ForeignKeys.Count - 1; i >= 0; i--)
                    if (!ForeignKeys.Any(o => o.Name == t.ForeignKeys[i].Name))
                    {
                        Model.Log("DROP FOREIGN KEY " + t.ForeignKeys[i].Name);
                        t.ForeignKeys[i].Drop();
                    }

                // Удалить все триггеры
                /*for (int i = 0; i < t.Triggers.Count; i++)
                {
                    Model.Log("DROP TRIGGER " + t.Triggers[i].Name);
                    t.Triggers[i].MarkForDrop(true);
                }*/

                // Удалить лишние столбцы
				foreach (Microsoft.SqlServer.Management.Smo.Column c in t.Columns.Cast<Microsoft.SqlServer.Management.Smo.Column>().ToList())
				{
					if (c.Computed)
					{
						Model.Log("DROP COMPUTED COLUMN " + c.Name);
						c.Drop();
					}
				}
                for (int i = 0; i < t.Columns.Count; i++)
                {
                    if (!t.Columns[i].InPrimaryKey && !Columns.Any(o => o.Name == t.Columns[i].Name))
                    {
						if (!Model.ScriptOnly)
						{
							foreach (Index index in t.Indexes.OfType<Index>().ToList())
							{
								if (index.IndexedColumns.OfType<IndexedColumn>().Any(o => o.Name == t.Columns[i].Name))
								{
									Model.Log("DROP INDEX " + index.Name);
									index.Drop();
								}
							}
						}
                        Model.Log("DROP COLUMN " + t.Columns[i].Name);

                        t.Columns[i].MarkForDrop(true);
                    }
                }
            }
            else
            {
                Model.Log("CREATE TABLE " + Name);
                t = new Microsoft.SqlServer.Management.Smo.Table(Model.Database, Name);

                // Добавление столбца
                foreach(var name in pknames)
					t.Columns.Add(new Microsoft.SqlServer.Management.Smo.Column(t,
						name, (Columns.FirstOrDefault(c1 => c1.Name == name) ?? new Column { Type = PkType }).Type) { Nullable = false });
				if (Model.Identity && pknames.Length == 1 && PkType.SqlDataType == SqlDataType.Int)
                    t.Columns[0].Identity = Identity;
				if (pknames.Length > 0)
				{
					t.Columns[0].ExtendedProperties.Add(new ExtendedProperty(t.Columns[0], "MS_Description", "Идентификатор"));

					if (PkType.SqlDataType == SqlDataType.UniqueIdentifier)
					{
						DefaultConstraint dc = t.Columns[0].AddDefaultConstraint();
						dc.Text = "newid()";
					}
				}

                t.ExtendedProperties.Add(new Microsoft.SqlServer.Management.Smo.ExtendedProperty(t, "IsAutoGenerated", 1));

                // Добавление первичного ключа
				Microsoft.SqlServer.Management.Smo.Index pkIndex = null;
				if (pknames.Length > 0)
				{
					pkIndex = new Microsoft.SqlServer.Management.Smo.Index(t, "PK_" + t.Name);
					pkIndex.IndexKeyType = Microsoft.SqlServer.Management.Smo.IndexKeyType.DriPrimaryKey;
					foreach (var column in t.Columns.OfType<Microsoft.SqlServer.Management.Smo.Column>())
						pkIndex.IndexedColumns.Add(new Microsoft.SqlServer.Management.Smo.IndexedColumn(pkIndex, column.Name));
					t.Indexes.Add(pkIndex);

					foreach (var s in t.Script().OfType<string>())
						Model.Script(s);

				}
                //if (!Model.ScriptOnly)
                //    t.Create();

				if (pkIndex != null)
				{
					foreach (var s in pkIndex.Script().OfType<string>())
						Model.Script(s);
				}
                //if (!Model.ScriptOnly)
                //    pkIndex.Create();
            }
			

            // Обновить столбцы
			foreach (var o in Columns.Where(col => !PkName.Split(',').Contains(col.Name)).OrderBy(c => c.ComputedText ?? ""))
				o.Sync(this, t);

            foreach (var s in t.Script().OfType<string>())
                Model.Script(s);
			if (!Description.IsEmpty())
			{
				var desc = t.ExtendedProperties["MS_Description"];
				if (desc == null)
					t.ExtendedProperties.Add(new ExtendedProperty(t, "MS_Description", Description));
				else
					desc.Value = Description;
			}
            if (!Model.ScriptOnly)
            {
				if (t.State == Microsoft.SqlServer.Management.Smo.SqlSmoState.Creating)
					t.Create();
				else
				{
					t.Alter();
					// Переименовать первичный ключ
					if (pknames.Length == 1)
					{
						var pk = t.Columns.Cast<Microsoft.SqlServer.Management.Smo.Column>().FirstOrDefault(o => o.InPrimaryKey);
						if (pk.Name != pknames[0])
						{
							Model.Log("RENAME PRIMARY KEY TO " + pknames[0]);
							Model.ServerConnection.ExecuteNonQuery(String.Format("sp_rename '{0}.{1}.{2}', '{3}', 'COLUMN'", t.Schema, t.Name, pk.Name, pknames[0]));
						}
					}
				}
            }

            // Создать триггеры
            foreach (var o in Triggers)
                o.Sync(this);
        }

        /// <summary>
        /// Синхронизация внешних ключей
        /// </summary>
        internal void SyncFK()
        {
            // Обновить внешние ключи
            foreach (var o in ForeignKeys)
                o.Sync(this, t);
        }
    }
}
