<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension="cs" #>
<#@ assembly name="System.Core.dll" #>
<#@ assembly name="System.Data.dll" #>
<#@ assembly name="System.Data.Linq.dll" #>
<#@ assembly name="System.Configuration.dll" #>
<#@ assembly name="$(ProjectDir)$(OutDir)Nephrite.Metamodel.dll" #>
<#@ assembly name="$(ProjectDir)$(OutDir)Nephrite.Web.dll" #>
<#@ assembly name="$(ProjectDir)$(OutDir)NHibernate.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="Nephrite.Meta" #>
<#@ import namespace="Nephrite.Meta.Database" #>
<#@ import namespace="Nephrite.Web" #>
<#@ import namespace="Nephrite.Web.Hibernate" #>
<#@ import namespace="Nephrite.Web.CoreDataContext" #>
<#@ import namespace="NHibernate.Cfg.Loquacious" #>

<# 
	A.DBScript = new DBScriptMSSQL("DBO");
	ConnectionManager.SetConnectionString("Integrated Security=SSPI;Persist Security Info=False;Initial Catalog=Servants;Data Source=(local)");
	HDataContext.DBType = DBType.MSSQL;

	A.Model = new HCoreDataContext(HCoreDataContext.DefaultDBConfig(ConnectionManager.ConnectionString), null);
	var model =  A.DynamicMeta;

#>
using System;
using System.Linq;
using Nephrite.Meta;
using Nephrite.Meta.Fluent;

namespace Solution.Model
{
<# foreach (var pck in model.Packages) { #>
<# foreach (var cls in pck.Classes) { #>
	public partial class <#=cls.Name#> { }
<# } #>

	public class <#=pck.Name#>Module
	{
		public MetaPackage Init()
		{
			var p = new MetaPackage("<#=pck.Name#>");
<# foreach (var cls in pck.Classes) { #>
			p.AddClass<<#=cls.Name#>>()
<#		if (cls.CompositeKey.Count == 1 && cls.Key.Type is MetaIntType) { #>
				.IntKey()
<#		} #>
<#		if (cls.CompositeKey.Count == 1 && cls.Key.Type is MetaGuidType) { #>
				.GuidKey()
<#		} #>
<#		foreach (var prop in cls.Properties) {
			if (prop is MetaAttribute && prop.Name != "IsDeleted") { #>
<#				string typeparm = prop.Type is MetaEnumType ? "\"" + prop.Type.Name + "\"" : ""; #>
				.Attribute("<#=prop.Name#>", "<#=prop.Caption#>", <#=prop.Type.GetType().Name#>.<#=(prop.Type as MetaPrimitiveType).NotNullable ? "NotNull(" + typeparm + ")" : "Null(" + typeparm + ")"#>)
<#			}
			if (prop is MetaComputedAttribute) { #>
				.ComputedAttribute("<#=prop.Name#>", "<#=prop.Caption#>", <#=prop.Type.GetType().Name#>.<#=(prop.Type as MetaPrimitiveType).NotNullable ? "NotNull()" : "Null()"#>)
<#			}
			if (prop is MetaPersistentComputedAttribute) { #>
				.PersistentComputedAttribute("<#=prop.Name#>", "<#=prop.Caption#>", <#=prop.Type.GetType().Name#>.<#=(prop.Type as MetaPrimitiveType).NotNullable ? "NotNull()" : "Null()"#>)
<#			}

			if (prop is MetaReference) { 
				var r = prop as MetaReference;
				string add = "";
				if (r.UpperBound == -1) add += ".Multiple()";
				if (r.AssociationType == AssociationType.Aggregation) add += ".Aggregation()";
				if (r.InverseProperty != null) add += @".InverseProperty(""" + r.InverseProperty.Name + @""")";
			#>
				.Reference<<#=r.RefClass.Name#>>("<#=prop.Name#>", "<#=prop.Caption#>"<#=!add.IsEmpty() ? ", x => x" + add : "" #>)
<#			} 
		} #>
<#		foreach (var op in cls.Operations) { #>
<#			if (op.Name == "CreateNew" && (op.Parameters.Count == 0 || op.Parameters.Count == 1)) { #>
				.OperationCreateNew()
<#			} else if (op.Name == "ViewList" && op.Parameters.Count == 0) { #>
				.OperationList()
<#			} else if (op.Name == "Edit" && (op.Parameters.Count == 0 || op.Parameters.Count == 2)) { #>
				.OperationEdit()				
<#			} else if (op.Name == "View" && (op.Parameters.Count == 0 || op.Parameters.Count == 2)) { #>
				.OperationView()
<#			} else if (op.Name == "Delete" && (op.Parameters.Count == 0 || op.Parameters.Count == 2)) { #>
				.OperationDelete()
<#			} else if (op.Name == "UnDelete" && (op.Parameters.Count == 0 || op.Parameters.Count == 2)) { #>
				.LogicalDelete()
<#			} else { #>
				.Operation("<#=op.Name#>", "<#=op.Caption#>"<# if (op.Parameters.Count > 0) { #>, x => x<# } else {#>)<# } #> 
<#				foreach (var p in op.Parameters) { #>
					.Parm(<#=p.Type.GetType().Name#>.NotNull(), "<#=p.Name#>")
<#				} 
				if (op.Parameters.Count > 0) { #>
				)
<#				} #>
<#			} #>
<# } #>
			;	
<# } #>
			return p;
		}
	}
<# } #>
}